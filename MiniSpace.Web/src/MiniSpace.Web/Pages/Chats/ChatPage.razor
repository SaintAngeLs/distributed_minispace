@page "/chats/{ChatId:guid}"
@using MiniSpace.Web.HttpClients
@using MiniSpace.Web.Areas.Communication
@using MiniSpace.Web.DTO.Communication
@inject IIdentityService IdentityService
@inject ICommunicationService CommunicationService
@inject IStudentsService StudentsService
@inject NavigationManager NavigationManager
@inject ISnackbar Snackbar
@using MudBlazor
@using System.Text.Json
@inject ChatSignalRService ChatSignalRService
@inject IJSRuntime JSRuntime
@implements IAsyncDisposable
@using System.Threading;

<AuthWrapper>
    <MudContainer Class="chat-container">
        <MudGrid>
            <MudItem xs="4" sm="2" md="4" Class="conversation-list-container">
                <MudPaper Class="   overflow-x-auto conversation-list" Height="100vh">
                    <MudCard>
                        @foreach (var chat in userChats)
                        {
                            <MudListItem @onclick="@(() => SelectChat(chat.Id))" Class="@GetChatItemClass(chat.Id)">
                                <div class="d-flex flex-grow-1 gap-4">
                                <MudAvatar>
                                    <MudImage Src="@GetChatImage(chat.Id)" Size="Size.Small"></MudImage>
                                    @if (GetUnreadMessageCount(chat.Id) > 0)
                                    {
                                        <MudBadge Content="@GetUnreadMessageCount(chat.Id)" Color="Color.Primary" Class="unread-badge" />
                                    }
                                </MudAvatar>
                                <MudText  Align="Align.Right" Class="chat-name">@GetChatName(chat.Id)</MudText>
                                </div>
                            </MudListItem>
                        }
                    </MudCard>
                </MudPaper>
            </MudItem>
            <MudItem xs="8" sm="10"  md="8" Class="chat-window-container">
                <MudPaper Class="d-flex flex-column chat-window" Height="100vh">

                    <!-- User Information Section -->
                    <div class="user-info-container d-flex align-items-center p-2 border-bottom">
                        <MudAvatar Class="mr-2">
                            <MudImage Src="@GetChatImage(ChatId)" Size="Size.Medium"></MudImage>
                        </MudAvatar>
                        <div class="user-details flex-grow-1">
                            <MudText Typo="Typo.h6">@GetChatName(ChatId)</MudText>
                            @* <MudText Typo="Typo.body2" Color="Color.Secondary">@GetUserStatus(ChatId)</MudText> *@
                        </div>
                        <MudIconButton Icon="@Icons.Material.Filled.MoreVert" />
                    </div>

                    <!-- Chat Messages Section -->
                    <div id="chatMessagesContainer" class="chat-messages flex-grow-1 overflow-auto">
                        @if (messages != null)
                        {
                            @foreach (var message in messages)
                            {
                                <div class="message-bubble @GetMessageBubbleClass(message)">
                                    <!-- User Avatar -->
                                    <div class="message-avatar">
                                        <MudAvatar>
                                            <MudImage Src="@GetSenderImage(message.SenderId)" Size="Size.Small"></MudImage>
                                        </MudAvatar>
                                    </div>

                                    <!-- Message Content -->
                                    <div class="message-content">
                                        <!-- Message Header with Sender Name and Timestamp -->
                                        <div class="message-header">
                                            <span class="message-sender">@GetSenderName(message.SenderId)</span>
                                            <span class="message-time">@message.Timestamp.ToString("HH:mm")</span>
                                        </div>

                                        <!-- Message Text -->
                                        <div class="message-text">@message.Content</div>

                                        <!-- Message Status (Sent, Delivered, Read) -->
                                        <div class="message-status">
                                            <MudIcon Icon="@GetStatusIcon(message.Status)" Color="Color.Secondary" Size="Size.Small" />
                                        </div>
                                    </div>
                                </div>
                            }
                        }
                    </div>

                    <!-- Typing Indicator -->
                    @if (isUserTyping)
                    {
                        <div class="typing-indicator">
                            @typingUserName is typing...
                        </div>
                    }

                    <!-- Message Input Section -->
                    <div class="message-input-container">
                        <input @bind="newMessageContent" @oninput="HandleInputChange" placeholder="Type a message..." disabled="@(!isConnected)" />
                        <MudIconButton Icon="@Icons.Material.Filled.Send" Color="Color.Primary" Disabled="@IsSendButtonDisabledCombined" @onclick="SendMessage" />
                    </div>

                    <!-- Connection Status -->
                    @if (!isConnected)
                    {
                        <MudText Class="connection-status" Color="Color.Error">
                            You are currently disconnected. Some features may be unavailable.
                        </MudText>
                    }
                </MudPaper>
            </MudItem>
        </MudGrid>
    </MudContainer>
</AuthWrapper>

<style>
    .chat-container {
        height: 100vh;
        padding: 0;
    }
    .conversation-list-container {
        border-right: 1px solid #E0E0E0;
        height: 100%;
    }
    .chat-window-container {
        height: 100%;
    }
    .conversation-list {
        height: 100%;
        overflow-y: auto;
    }
    .chat-window {
        display: flex;
        flex-direction: column;
        height: 100%;
    }
    .chat-messages {
        flex-grow: 1;
        overflow-y: auto;
        padding: 16px;
        background-color: #FAFAFA;
    }
    .message-bubble {
        display: flex;
        align-items: flex-start;
        margin-bottom: 20px;
        padding: 12px;
        border-radius: 10px;
        max-width: 70%;
        background-color: #E0F7FA;
        position: relative;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .message-bubble.received {
        background-color: #FFFFFF;
        margin-right: auto;
    }
    .message-bubble.sent {
        background-color: #E0F7FA;
        margin-left: auto;
    }
    .message-avatar {
        margin-right: 10px;
    }
    .message-content {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
    }
    .message-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 4px;
        color: #607d8b;
    }
    .message-sender {
        font-weight: 500;
        color: #455a64;
    }
    .message-time {
        font-size: 12px;
        color: #78909c;
    }
    .message-text {
        margin-bottom: 6px;
        color: #37474f;
        font-family: 'Roboto', sans-serif;
        font-size: 14px;
        line-height: 1.4;
    }
    .message-status {
        display: flex;
        justify-content: flex-end;
        margin-top: 4px;
    }
    .message-input-container {
        display: flex;
        align-items: center;
        padding: 12px 16px;
        background-color: #FFFFFF;
        border-top: 1px solid #E0E0E0;
    }

    .unread-chat {
        background-color: #E3F2FD; 
    }

    .unread-badge {
        position: absolute;
        top: 0;
        right: 0;
        border-radius: 50%;
        transform: translate(50%, -50%);
    }

    .chat-name {
        display: block;
        margin-left: 8px;
    }

    .typing-indicator {
        font-style: italic;
        color: #555;
        margin-bottom: 10px;
    }

    .connection-status {
        text-align: center;
        margin-top: 10px;
    }

    .user-info-container {
        display: flex;
        align-items: center;
        padding: 8px;
        border-bottom: 1px solid #E0E0E0;
    }

    .user-info-container .user-details {
        margin-left: 8px;
        flex-grow: 1;
    }

    .user-info-container .user-status {
        font-size: 14px;
        color: #9e9e9e;
    }
</style>

@code {
    [Parameter] public Guid ChatId { get; set; }

    private List<ChatDto> userChats = new();
    private List<MessageDto> messages = new();
    private string newMessageContent = string.Empty;
    private Dictionary<Guid, string> userNames = new();
    private Dictionary<Guid, string> userImages = new();
    private bool isSending = false;
    private bool hasUpdatedStatus = false;
    private bool isUserTyping = false;
    private string typingUserName = string.Empty;
    private Timer typingTimer;
    private bool isConnected = true;
    private bool IsSendButtonDisabledCombined => IsSendButtonDisabled || !isConnected;

    private bool IsSendButtonDisabled => isSending || string.IsNullOrWhiteSpace(newMessageContent);

    protected override async Task OnInitializedAsync()
    {
        await IdentityService.InitializeAuthenticationState();

        if (IdentityService.IsAuthenticated)
        {
            await LoadUserChats();
            if (ChatId != Guid.Empty)
            {
                await LoadMessages(ChatId);
            }

            var userId = IdentityService.GetCurrentUserId();
            await ChatSignalRService.StartAsync(userId, ChatId);
            ChatSignalRService.MessageReceived += OnMessageReceived;
            ChatSignalRService.MessageStatusUpdated += OnMessageStatusUpdated;
            ChatSignalRService.TypingNotificationReceived += OnTypingNotificationReceived;
            ChatSignalRService.ConnectionChanged += OnConnectionChanged;
        }
        else
        {
            NavigationManager.NavigateTo("/login");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await ScrollToBottomAsync();
        }
        else
        {
            await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatMessagesContainer");
        }

        if (!hasUpdatedStatus)
        {
            hasUpdatedStatus = true;
            await Task.Delay(1000);
            await UpdateUnreadMessagesStatusAsync();
        }
    }

    private async void OnTypingTimeout(object state)
    {
        await InvokeAsync(() =>
        {
            isUserTyping = false;
            typingUserName = string.Empty;
            StateHasChanged();
        });

        typingTimer?.Dispose();
    }

    private async Task HandleInputChange(ChangeEventArgs e)
    {
        if (e.Value is string inputValue)
        {
            await ChatSignalRService.SendTypingNotificationAsync(!string.IsNullOrEmpty(inputValue));

            typingTimer?.Dispose();
            typingTimer = new Timer(OnTypingTimeout, null, 1000, Timeout.Infinite);
        }
    }

    private async void OnTypingNotificationReceived(string userId, bool isTyping)
    {
        await InvokeAsync(() =>
        {
            if (isTyping)
            {
                if (userNames.TryGetValue(Guid.Parse(userId), out var userName))
                {
                    typingUserName = userName;
                }
                else
                {
                    typingUserName = "Unknown User";
                }

                isUserTyping = true;

                typingTimer?.Dispose();
                typingTimer = new Timer(OnTypingTimeout, null, 1000, Timeout.Infinite);
            }
            else
            {
                isUserTyping = false;
                typingUserName = string.Empty;
            }

            StateHasChanged();
        });
    }

    private async void OnConnectionChanged(bool connected)
    {
        await InvokeAsync(() =>
        {
            isConnected = connected;
            StateHasChanged();
        });
    }

    private async Task LoadUserChats()
    {
        try
        {
            var userId = IdentityService.GetCurrentUserId();
            var result = await CommunicationService.GetUserChatsAsync(userId, 1, 20);

            if (result != null)
            {
                userChats = result.Items.SelectMany(u => u.Chats).ToList();
                await LoadUserDetails();
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load chats: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadMessages(Guid chatId)
    {
        try
        {
            messages = (await CommunicationService.GetMessagesForChatAsync(chatId)).ToList();
            await LoadUserDetails();
            await ScrollToBottomAsync();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Failed to load messages: {ex.Message}", Severity.Error);
        }
    }

    private async Task LoadUserDetails()
    {
        var senderIds = messages.Select(m => m.SenderId).Distinct().ToList();
        var chatUserIds = userChats.SelectMany(c => c.ParticipantIds).Distinct().ToList();
        var allUserIds = senderIds.Union(chatUserIds).Distinct().ToList();

        foreach (var userId in allUserIds)
        {
            if (!userNames.ContainsKey(userId))
            {
                var user = await StudentsService.GetStudentAsync(userId);
                if (user != null)
                {
                    userNames[userId] = $"{user.FirstName} {user.LastName}";
                    userImages[userId] = string.IsNullOrWhiteSpace(user.ProfileImageUrl) ? "images/default_profile_image.webp" : user.ProfileImageUrl;
                }
            }
        }
    }

    private async Task SendMessage()
    {
        if (!string.IsNullOrWhiteSpace(newMessageContent) && !isSending)
        {
            isSending = true;

            try
            {
                var userId = IdentityService.GetCurrentUserId();
                var command = new SendMessageCommand(ChatId, userId, newMessageContent);

                var response = await CommunicationService.SendMessageAsync(command);
                if (response.IsSuccessStatusCode)
                {
                    newMessageContent = string.Empty;
                    Snackbar.Add("Message sent!", Severity.Success);
                    await ScrollToBottomAsync();
                }
                else
                {
                    Snackbar.Add("Failed to send message.", Severity.Error);
                }
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error: {ex.Message}", Severity.Error);
            }
            finally
            {
                isSending = false;
            }
        }
    }

    private async Task ScrollToBottomAsync()
    {
        await JSRuntime.InvokeVoidAsync("scrollToBottom", "chatMessagesContainer");
    }

    private async Task UpdateUnreadMessagesStatusAsync()
    {
        var unreadMessages = messages
            .Where(m => m.SenderId != IdentityService.GetCurrentUserId() && m.Status != "Read")
            .ToList();

        if (unreadMessages.Any())
        {
            foreach (var message in unreadMessages)
            {
                await UpdateMessageStatus(message, "Read");
            }
        }
    }

    private async Task UpdateMessageStatus(MessageDto message, string status)
    {
        if (message.ChatId == Guid.Empty || message.Id == Guid.Empty)
        {
            Snackbar.Add("Invalid message ID or chat ID.", Severity.Error);
            return;
        }

        var command = new UpdateMessageStatusCommand(message.ChatId, message.Id, status);
        var response = await CommunicationService.UpdateMessageStatusAsync(command);

        if (response.IsSuccessStatusCode)
        {
            message.Status = status;
        }
        else
        {
            Snackbar.Add($"Failed to update message status: {response.ErrorMessage}", Severity.Error);
        }
    }

    private void SelectChat(Guid chatId)
    {
        NavigationManager.NavigateTo($"/chats/{chatId}");
    }

    private string GetChatItemClass(Guid chatId)
    {
        return ChatId == chatId ? "selected-chat" : string.Empty;
    }

    private int GetUnreadMessageCount(Guid chatId)
    {
        return messages.Count(m => m.ChatId == chatId && m.SenderId != IdentityService.GetCurrentUserId() && m.Status != "Read");
    }

    private string GetMessageBubbleClass(MessageDto message)
    {
        return message.SenderId == IdentityService.GetCurrentUserId() ? "sent" : "received";
    }

    private string GetSenderName(Guid senderId)
    {
        return userNames.TryGetValue(senderId, out var name) ? name : "Unknown";
    }

    private string GetSenderImage(Guid senderId)
    {
        return userImages.TryGetValue(senderId, out var imageUrl) ? imageUrl : "/images/default_profile_image.webp";
    }

    private string GetChatImage(Guid chatId)
    {
         if (IdentityService.IsAuthenticated)
        {
        var chat = userChats.FirstOrDefault(c => c.Id == chatId);

        if (chat == null)
        {
            return "/images/default_profile_image.webp";
        }

       
            var userId = IdentityService.GetCurrentUserId();
            if (chat.ParticipantIds.Count == 2)
            {
                // Get the ID of the other participant
                var otherParticipantId = chat.ParticipantIds.FirstOrDefault(id => id != userId);
                
                // Return the image of the other participant or the default image if none is available
                return GetSenderImage(otherParticipantId);
            }

            // For chats with more than two participants or if the logic above fails
            var otherParticipant = chat.ParticipantIds.FirstOrDefault(id => id != userId);
            if (otherParticipant != Guid.Empty)
            {
                return GetSenderImage(otherParticipant);
            }
        }
        
        return "/images/default_profile_image.webp";
    }


    private string GetChatName(Guid chatId)
    {
        var chat = userChats.FirstOrDefault(c => c.Id == chatId);

        if (IdentityService.IsAuthenticated)
        {
            var userId = IdentityService.GetCurrentUserId();
            if (chat != null && chat.ParticipantIds.Count == 2)
            {
                // Get the ID of the other participant
                var otherParticipantId = chat.ParticipantIds.FirstOrDefault(id => id != userId);
                
                // Return the name of the other participant
                return userNames.TryGetValue(otherParticipantId, out var otherParticipantName) 
                    ? otherParticipantName 
                    : "Unknown Chat";
            }

            // Return the chat's custom name or a default name if it has more than 2 participants
            return chat?.Name ?? "Unknown Chat";
        }
        return "Unknown Chat";
    }

    private async void OnMessageReceived(MessageDto message)
    {
        await InvokeAsync(() =>
        {
            if (message.ChatId == ChatId)
            {
                if (!messages.Any(m => m.Id == message.Id))
                {
                    messages.Add(message);
                    ScrollToBottomAsync();
                    StateHasChanged();
                }
            }
        });
    }

    private async void OnMessageStatusUpdated(Guid messageId, string status)
    {
        await InvokeAsync(() =>
        {
            var message = messages.FirstOrDefault(m => m.Id == messageId);
            if (message != null)
            {
                message.Status = status;
                StateHasChanged();
            }
        });
    }

    private string GetStatusIcon(string status)
    {
        return status switch
        {
            "Sent" => Icons.Material.Filled.Check,
            "Delivered" => Icons.Material.Filled.DoneAll,
            "Read" => Icons.Material.Filled.Visibility,
            _ => Icons.Material.Filled.Schedule // Default icon for pending or unknown status
        };
    }

    public async ValueTask DisposeAsync()
    {
        ChatSignalRService.MessageReceived -= OnMessageReceived;
        ChatSignalRService.MessageStatusUpdated -= OnMessageStatusUpdated;
        ChatSignalRService.TypingNotificationReceived -= OnTypingNotificationReceived;
        ChatSignalRService.ConnectionChanged -= OnConnectionChanged;
        await ChatSignalRService.DisposeAsync();
        typingTimer?.Dispose();
    }
}
